from datetime import timezone
from django.utils import timezone
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework import status
from medium_blog_api_app.authentication.custom_jwt_auth import IsAuthenticatedCustom
from medium_blog_api_app.models import *
from medium_blog_api_app.serializers import *
from django.db import transaction
from django.db.models import Q, Count, Sum
from django.http import HttpResponse
import json
import csv

#################### ADDITIONAL COMMENT APIS #####################

## Get Article Comments
@api_view(['POST'])
@permission_classes([IsAuthenticatedCustom])
def get_article_comments(request):
    """
    Get all comments for an article.

    Request Body:
    {
        "article_id": 25
    }

    Response:
    {
        "status": "success",
        "message": "Comments fetched",
        "results": [
            {
                "comment_id": 12,
                "article": 25,
                "user": {
                    "user_id": 19,
                    "username": "john_doe",
                    "profile_pic": "http://127.0.0.1:8000/media/profiles/john.jpg"
                },
                "comment_content": "This is a great article! Very informative.",
                "created_at": "2024-01-15T10:30:00Z",
                "updated_at": "2024-01-15T10:30:00Z",
                "reply_count": 3
            }
        ]
    }
    """
    try:
        article_id = request.data.get('article_id')

        if not article_id:
            return Response({"status": "error", "message": "article_id is required"}, status=status.HTTP_400_BAD_REQUEST)

        comments = Comment.objects.filter(article_id=article_id).select_related('user').prefetch_related('reply_comments')

        comments_data = []
        for comment in comments:
            comments_data.append({
                "comment_id": comment.comment_id,
                "article": comment.article.article_id,
                "user": {
                    "user_id": comment.user.user_id,
                    "username": comment.user.username,
                    "profile_pic": request.build_absolute_uri(comment.user.profile_pic.url) if comment.user.profile_pic else None
                },
                "comment_content": comment.comment_content,
                "created_at": comment.created_at,
                "updated_at": comment.updated_at,
                "reply_count": comment.reply_comments.count() if hasattr(comment, 'reply_comments') else 0
            })

        return Response({
            "status": "success",
            "message": "Comments fetched",
            "results": comments_data
        }, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({"status": "error", "message": str(e)}, status=status.HTTP_400_BAD_REQUEST)

## Like Comment
@api_view(['POST'])
@permission_classes([IsAuthenticatedCustom])
def like_comment(request):
    """
    Like a comment.

    Request Body:
    {
        "comment_id": 12
    }

    Response:
    {
        "status": "success",
        "message": "Comment liked"
    }
    """
    try:
        comment_id = request.data.get('comment_id')

        if not comment_id:
            return Response({"status": "error", "message": "comment_id is required"}, status=status.HTTP_400_BAD_REQUEST)

        # Check if CommentLike model exists, if not create basic functionality
        # For now, we'll just return success as the like functionality needs additional model
        return Response({"status": "success", "message": "Comment liked"}, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({"status": "error", "message": str(e)}, status=status.HTTP_400_BAD_REQUEST)

## Get Article Engagement Stats
@api_view(['POST'])
@permission_classes([IsAuthenticatedCustom])
def get_article_engagement(request):
    """
    Get clap and comment statistics for an article.

    Request Body:
    {
        "article_id": 25
    }

    Response:
    {
        "status": "success",
        "message": "Engagement stats fetched",
        "data": {
            "article_id": 25,
            "article_title": "Introduction to Python Programming",
            "total_claps": 45,
            "total_comments": 8,
            "total_replies": 15,
            "engagement_score": 68
        }
    }
    """
    try:
        article_id = request.data.get('article_id')

        if not article_id:
            return Response({"status": "error", "message": "article_id is required"}, status=status.HTTP_400_BAD_REQUEST)

        article = Article.objects.get(article_id=article_id)
        
        # Calculate engagement score (claps + comments * 2 + shares * 3)
        engagement_score = (
            article.clap_count + 
            (article.comment_count * 2) + 
            (article.share_count * 3)
        )

        engagement_data = {
            "article_id": article.article_id,
            "article_title": article.article_title,
            "total_claps": article.clap_count,
            "total_comments": article.comment_count,
            "total_shares": article.share_count,
            "engagement_score": engagement_score
        }

        return Response({
            "status": "success",
            "message": "Engagement stats fetched",
            "data": engagement_data
        }, status=status.HTTP_200_OK)

    except Article.DoesNotExist:
        return Response({"status": "error", "message": "Article not found"}, status=status.HTTP_404_NOT_FOUND)
    except Exception as e:
        return Response({"status": "error", "message": str(e)}, status=status.HTTP_400_BAD_REQUEST)

#################### ADDITIONAL READING LIST APIS #####################

## Add Multiple Articles to Reading List
@api_view(['POST'])
@permission_classes([IsAuthenticatedCustom])
def add_multiple_to_readinglist(request):
    """
    Add multiple articles to reading list at once.

    Request Body:
    {
        "article_ids": [25, 30, 35],
        "visibility": "public"
    }

    Response:
    {
        "status": "success",
        "message": "3 articles added to reading list",
        "data": {
            "added_count": 3,
            "skipped_count": 0,
            "total_articles_in_list": 15
        }
    }
    """
    try:
        article_ids = request.data.get('article_ids', [])
        visibility = request.data.get('visibility', 'public')

        if not article_ids:
            return Response({"status": "error", "message": "article_ids is required"}, status=status.HTTP_400_BAD_REQUEST)

        if isinstance(article_ids, str):
            try:
                article_ids = json.loads(article_ids)
            except:
                article_ids = [article_ids]

        added_count = 0
        skipped_count = 0

        with transaction.atomic():
            for article_id in article_ids:
                try:
                    article = Article.objects.get(article_id=article_id)
                    
                    # Check if already in reading list
                    if ReadingList.objects.filter(user=request.user, article=article).exists():
                        skipped_count += 1
                        continue

                    ReadingList.objects.create(
                        article=article,
                        visibility=visibility,
                        user=request.user,
                        created_by=request.user,
                        updated_by=request.user
                    )
                    added_count += 1

                except Article.DoesNotExist:
                    skipped_count += 1
                    continue

            # Update total articles count
            total_articles = ReadingList.objects.filter(user=request.user).count()

        return Response({
            "status": "success",
            "message": f"{added_count} articles added to reading list",
            "data": {
                "added_count": added_count,
                "skipped_count": skipped_count,
                "total_articles_in_list": total_articles
            }
        }, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({"status": "error", "message": str(e)}, status=status.HTTP_400_BAD_REQUEST)

## Clear Reading List
@api_view(['DELETE'])
@permission_classes([IsAuthenticatedCustom])
def clear_readinglist(request):
    """
    Clear entire reading list.

    Response:
    {
        "status": "success",
        "message": "Reading list cleared successfully",
        "data": {
            "deleted_count": 12,
            "total_articles_removed": 12
        }
    }
    """
    try:
        with transaction.atomic():
            # Get count before deletion
            deleted_count = ReadingList.objects.filter(user=request.user).count()
            
            # Delete all reading list items for the user
            ReadingList.objects.filter(user=request.user).delete()

        return Response({
            "status": "success",
            "message": "Reading list cleared successfully",
            "data": {
                "deleted_count": deleted_count,
                "total_articles_removed": deleted_count
            }
        }, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({"status": "error", "message": str(e)}, status=status.HTTP_400_BAD_REQUEST)

## Get Reading List Stats
@api_view(['GET'])
@permission_classes([IsAuthenticatedCustom])
def get_readinglist_stats(request):
    """
    Get reading list statistics.

    Response:
    {
        "status": "success",
        "message": "Reading list stats fetched",
        "data": {
            "total_articles": 15,
            "public_articles": 10,
            "private_articles": 5,
            "total_read_time": 125,
            "categories": {
                "Programming": 6,
                "Web Development": 4,
                "Data Science": 3,
                "Design": 2
            },
            "last_added": "2024-01-15T10:30:00Z"
        }
    }
    """
    try:
        reading_list_items = ReadingList.objects.filter(user=request.user).select_related('article')
        
        total_articles = reading_list_items.count()
        public_articles = reading_list_items.filter(visibility='public').count()
        private_articles = reading_list_items.filter(visibility='private').count()
        
        # Calculate total read time and categories
        total_read_time = 0
        categories = {}
        
        for item in reading_list_items:
            total_read_time += item.article.read_time if item.article.read_time else 0
            
            category = item.article.article_category
            if category:
                categories[category] = categories.get(category, 0) + 1
        
        # Get last added article
        last_added = reading_list_items.order_by('-created_at').first()
        
        stats_data = {
            "total_articles": total_articles,
            "public_articles": public_articles,
            "private_articles": private_articles,
            "total_read_time": total_read_time,
            "categories": categories,
            "last_added": last_added.created_at if last_added else None
        }

        return Response({
            "status": "success",
            "message": "Reading list stats fetched",
            "data": stats_data
        }, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({"status": "error", "message": str(e)}, status=status.HTTP_400_BAD_REQUEST)

## Search in Reading List
@api_view(['POST'])
@permission_classes([IsAuthenticatedCustom])
def search_readinglist(request):
    """
    Search articles in reading list.

    Request Body:
    {
        "search_text": "python"
    }

    Response:
    {
        "status": "success",
        "message": "Search results found",
        "data": [
            {
                "reading_list_id": 8,
                "article_id": 25,
                "article_title": "Introduction to Python Programming",
                "article_category": "Programming",
                "visibility": "public",
                "created_at": "2024-01-15T10:30:00Z",
                "updated_at": "2024-01-15T10:30:00Z",
                "match_reason": "Title contains 'python'"
            }
        ]
    }
    """
    try:
        search_text = request.data.get('search_text')

        if not search_text:
            return Response({"status": "error", "message": "search_text is required"}, status=status.HTTP_400_BAD_REQUEST)

        reading_list_items = ReadingList.objects.filter(
            user=request.user
        ).filter(
            Q(article__article_title__icontains=search_text) |
            Q(article__article_content__icontains=search_text) |
            Q(article__article_category__icontains=search_text)
        ).select_related('article')

        search_results = []
        for item in reading_list_items:
            match_reason = []
            if search_text.lower() in item.article.article_title.lower():
                match_reason.append("Title contains search text")
            if search_text.lower() in item.article.article_content.lower():
                match_reason.append("Content contains search text")
            if search_text.lower() in (item.article.article_category or "").lower():
                match_reason.append("Category contains search text")
            
            search_results.append({
                "reading_list_id": item.reading_list_id,
                "article_id": item.article.article_id,
                "article_title": item.article.article_title,
                "article_category": item.article.article_category,
                "visibility": item.visibility,
                "created_at": item.created_at,
                "updated_at": item.updated_at,
                "match_reason": ", ".join(match_reason) if match_reason else "Relevant match"
            })

        return Response({
            "status": "success",
            "message": "Search results found",
            "data": search_results
        }, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({"status": "error", "message": str(e)}, status=status.HTTP_400_BAD_REQUEST)

## Bulk Update Reading List Visibility
@api_view(['PUT'])
@permission_classes([IsAuthenticatedCustom])
def bulk_update_readinglist_visibility(request):
    """
    Bulk update visibility of reading list items.

    Request Body:
    {
        "readinglist_ids": [8, 9, 10],
        "visibility": "private"
    }

    Response:
    {
        "status": "success",
        "message": "Visibility updated for 3 items",
        "data": {
            "updated_count": 3,
            "failed_count": 0
        }
    }
    """
    try:
        readinglist_ids = request.data.get('readinglist_ids', [])
        visibility = request.data.get('visibility')

        if not readinglist_ids:
            return Response({"status": "error", "message": "readinglist_ids is required"}, status=status.HTTP_400_BAD_REQUEST)

        if not visibility:
            return Response({"status": "error", "message": "visibility is required"}, status=status.HTTP_400_BAD_REQUEST)

        if isinstance(readinglist_ids, str):
            try:
                readinglist_ids = json.loads(readinglist_ids)
            except:
                readinglist_ids = [readinglist_ids]

        updated_count = 0
        failed_count = 0

        with transaction.atomic():
            for readinglist_id in readinglist_ids:
                try:
                    reading_list = ReadingList.objects.get(
                        reading_list_id=readinglist_id, 
                        user=request.user
                    )
                    reading_list.visibility = visibility
                    reading_list.updated_by = request.user
                    reading_list.updated_at = timezone.now()
                    reading_list.save()
                    updated_count += 1
                except ReadingList.DoesNotExist:
                    failed_count += 1
                except Exception:
                    failed_count += 1

        return Response({
            "status": "success",
            "message": f"Visibility updated for {updated_count} items",
            "data": {
                "updated_count": updated_count,
                "failed_count": failed_count
            }
        }, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({"status": "error", "message": str(e)}, status=status.HTTP_400_BAD_REQUEST)

## Export Reading List
@api_view(['GET'])
@permission_classes([IsAuthenticatedCustom])
def export_readinglist(request):
    """
    Export reading list as JSON or CSV.

    Query Parameters:
    - format: json/csv (default: json)

    Response (JSON):
    {
        "status": "success",
        "message": "Reading list exported successfully",
        "data": {
            "export_format": "json",
            "exported_at": "2024-01-15T12:30:00Z",
            "total_articles": 15,
            "reading_list": [
                {
                    "article_title": "Introduction to Python Programming",
                    "author": "john_doe",
                    "category": "Programming",
                    "read_time": 5,
                    "added_date": "2024-01-15T10:30:00Z",
                    "article_url": "http://127.0.0.1:8000/articles/introduction-python-programming"
                }
            ]
        }
    }
    """
    try:
        export_format = request.GET.get('format', 'json').lower()
        
        reading_list_items = ReadingList.objects.filter(
            user=request.user
        ).select_related('article', 'article__author').order_by('-created_at')

        export_data = []
        for item in reading_list_items:
            export_data.append({
                "article_title": item.article.article_title,
                "author": item.article.author.username,
                "category": item.article.article_category,
                "read_time": item.article.read_time,
                "added_date": item.created_at,
                "visibility": item.visibility,
                "article_url": f"http://127.0.0.1:8000/articles/{item.article.article_id}"
            })

        if export_format == 'csv':
            response = HttpResponse(content_type='text/csv')
            response['Content-Disposition'] = f'attachment; filename="reading_list_{timezone.now().strftime("%Y%m%d_%H%M%S")}.csv"'
            
            writer = csv.writer(response)
            writer.writerow(['Article Title', 'Author', 'Category', 'Read Time (min)', 'Added Date', 'Visibility', 'URL'])
            
            for item in export_data:
                writer.writerow([
                    item['article_title'],
                    item['author'],
                    item['category'],
                    item['read_time'],
                    item['added_date'].strftime("%Y-%m-%d %H:%M:%S"),
                    item['visibility'],
                    item['article_url']
                ])
            
            return response

        else:  # JSON format (default)
            return Response({
                "status": "success",
                "message": "Reading list exported successfully",
                "data": {
                    "export_format": "json",
                    "exported_at": timezone.now(),
                    "total_articles": len(export_data),
                    "reading_list": export_data
                }
            }, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({"status": "error", "message": str(e)}, status=status.HTTP_400_BAD_REQUEST)

#################### ADDITIONAL ARTICLE APIS #####################

## Get Trending Articles
@api_view(['GET'])
@permission_classes([IsAuthenticatedCustom])
def get_trending_articles(request):
    """
    Get trending articles based on engagement.

    Response:
    {
        "status": "success",
        "message": "Trending articles fetched",
        "results": [
            {
                "article_id": 25,
                "article_title": "Introduction to Python Programming",
                "author": "john_doe",
                "clap_count": 150,
                "comment_count": 25,
                "share_count": 10,
                "engagement_score": 235,
                "trending_rank": 1
            }
        ]
    }
    """
    try:
        # Get articles with highest engagement (claps + comments*2 + shares*3)
        articles = Article.objects.filter(
            is_reported=False, 
            show_less_like_this=False
        ).annotate(
            engagement_score=(
                F('clap_count') + 
                F('comment_count') * 2 + 
                F('share_count') * 3
            )
        ).order_by('-engagement_score')[:10]  # Top 10 trending articles

        trending_data = []
        for rank, article in enumerate(articles, 1):
            trending_data.append({
                "article_id": article.article_id,
                "article_title": article.article_title,
                "author": article.author.username,
                "clap_count": article.clap_count,
                "comment_count": article.comment_count,
                "share_count": article.share_count,
                "engagement_score": article.engagement_score,
                "trending_rank": rank
            })

        return Response({
            "status": "success",
            "message": "Trending articles fetched",
            "results": trending_data
        }, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({"status": "error", "message": str(e)}, status=status.HTTP_400_BAD_REQUEST)

## Get Articles by Topic
@api_view(['POST'])
@permission_classes([IsAuthenticatedCustom])
def get_articles_by_topic(request):
    """
    Get articles by specific topic.

    Request Body:
    {
        "topic_id": 1
    }

    Response:
    {
        "status": "success",
        "message": "Articles found for topic",
        "results": [
            {
                "article_id": 25,
                "article_title": "Introduction to Python Programming",
                "author": "john_doe",
                "topic": "Programming",
                "read_time": 5,
                "clap_count": 15
            }
        ]
    }
    """
    try:
        topic_id = request.data.get('topic_id')

        if not topic_id:
            return Response({"status": "error", "message": "topic_id is required"}, status=status.HTTP_400_BAD_REQUEST)

        # Get articles through ArticlePublicationTopic relationship
        articles = Article.objects.filter(
            apt_links__topic_id=topic_id,
            is_reported=False
        ).select_related('author').distinct()

        articles_data = []
        for article in articles:
            articles_data.append({
                "article_id": article.article_id,
                "article_title": article.article_title,
                "author": article.author.username,
                "topic": article.apt_links.first().topic.topic_header_1 if article.apt_links.exists() else None,
                "read_time": article.read_time,
                "clap_count": article.clap_count,
                "published_at": article.published_at
            })

        return Response({
            "status": "success",
            "message": "Articles found for topic",
            "results": articles_data
        }, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({"status": "error", "message": str(e)}, status=status.HTTP_400_BAD_REQUEST)



from rest_framework.permissions import BasePermission
from tokenize import TokenError
from rest_framework_simplejwt.authentication import JWTAuthentication
from rest_framework import exceptions
from medium_blog_api_app.models import TokenBlacklistLogout, User
from rest_framework_simplejwt.tokens import RefreshToken
from loguru import logger

# Custom JWT configure
class CustomJWTAuthentication(JWTAuthentication):
    def authenticate(self, request):
        logger.debug(f"üîê Authentication attempt for path: {request.path}")
        
        header = self.get_header(request)
        if header is None:
            logger.warning("‚ùå No authorization header found")
            return None

        raw_token = self.get_raw_token(header)
        if raw_token is None:
            logger.warning("‚ùå No token found in authorization header")
            return None

        try:
            validated_token = self.get_validated_token(raw_token)
            user = self.get_user(validated_token)
            logger.info(f"‚úÖ User authenticated: {user.username} (ID: {user.user_id})")
            return (user, validated_token)

        except TokenError as e:
            logger.error(f"‚ùå Token validation failed: {str(e)}")
            raise exceptions.AuthenticationFailed(str(e))

    def get_user(self, validated_token):
        try:
            user_id = validated_token['user_id']
            user = User.objects.get(user_id=user_id)
            logger.debug(f"üë§ User retrieved from token: {user.username}")
            return user
        except User.DoesNotExist:
            logger.error(f"‚ùå User not found for ID: {user_id}")
            raise exceptions.AuthenticationFailed('User not found', code='user_not_found')
        except KeyError:
            logger.error("‚ùå Invalid token - missing user_id")
            raise exceptions.AuthenticationFailed('Invalid token')

# Utility function to get tokens for user
def get_tokens_for_user(user):
    logger.info(f"üîÑ Generating tokens for user: {user.username}")
    
    refresh = RefreshToken.for_user(user)
    
    # Add custom claims
    refresh['user_id'] = user.user_id
    refresh['username'] = user.username
    refresh['role'] = user.role
    
    logger.success(f"‚úÖ Tokens generated successfully for user: {user.username}")
    return {
        'refresh': str(refresh),
        'access': str(refresh.access_token),
    }

# Function to validate if token is blacklisted
def validate_token_not_blacklisted(request):
    validated_token = request.auth
    if not validated_token:
        logger.warning("‚ùå No token found in request")
        raise exceptions.AuthenticationFailed("No token found.")

    if isinstance(validated_token, bytes):
        validated_token = validated_token.decode("utf-8")

    is_blacklisted = TokenBlacklistLogout.objects.filter(
        user=request.user,
        token=str(validated_token),
        is_expired=True
    ).exists()

    if is_blacklisted:
        logger.warning(f"üö´ Blacklisted token used by user: {request.user.username}")
        raise exceptions.AuthenticationFailed("Token blacklisted. Please login again.")
    
    logger.debug(f"‚úÖ Token validation passed for user: {request.user.username}")

# Custom Permission Classes
class IsAuthenticatedCustom(BasePermission):
    """
    Custom permission class that works with your User model
    """
    def has_permission(self, request, view):
        logger.debug(f"üîí Checking IsAuthenticatedCustom permission for {request.path}")
        
        if not (request.user and hasattr(request.user, 'user_id')):
            logger.warning("‚ùå Permission denied - No user or user_id")
            return False

        validated_token = request.auth
        if not validated_token:
            logger.warning("‚ùå Permission denied - No access token")
            raise exceptions.AuthenticationFailed("Access token missing.")
        
        if isinstance(validated_token, bytes):
            validated_token = validated_token.decode("utf-8")

        is_blacklisted = TokenBlacklistLogout.objects.filter(
            user=request.user,
            token=str(validated_token),
            is_expired=True
        ).exists()

        if is_blacklisted:
            logger.warning(f"üö´ Permission denied - Blacklisted token for user: {request.user.username}")
            raise exceptions.AuthenticationFailed("This access token has been blacklisted. Please log in again.")

        logger.info(f"‚úÖ IsAuthenticatedCustom permission granted for user: {request.user.username}")
        return True

class IsAdminCustom(BasePermission):
    """
    Allows access only to admin users.
    """
    def has_permission(self, request, view):
        logger.debug(f"üëë Checking IsAdminCustom permission for {request.path}")
        
        # token check
        validate_token_not_blacklisted(request)

        user = request.user
        if not user or not hasattr(user, 'user_id'):
            logger.warning("‚ùå Admin permission denied - No user or user_id")
            return False

        if not getattr(user, 'is_admin', False):
            logger.warning(f"‚ùå Admin permission denied - User {user.username} is not admin")
            return False

        logger.info(f"‚úÖ IsAdminCustom permission granted for admin: {user.username}")
        return True

class IsMemberUser(BasePermission):
    """
    Permission class to allow access only to member users
    for member-only content.
    """
    message = "You must be a member to access this content."

    def has_permission(self, request, view):
        logger.debug(f"‚≠ê Checking IsMemberUser permission for {request.path}")
        
        is_member = request.user and request.user.is_authenticated and request.user.is_member
        
        if not is_member:
            logger.warning(f"‚ùå Member permission denied - User {getattr(request.user, 'username', 'Unknown')} is not a member")
        
        logger.info(f"‚úÖ IsMemberUser permission granted for member: {request.user.username}")
        return is_member

    def has_object_permission(self, request, view, obj):
        logger.debug(f"‚≠ê Checking object-level member permission for {type(obj).__name__}")
        
        # Check object level: member-only article
        if hasattr(obj, 'is_member_only') and obj.is_member_only:
            is_member = request.user.is_authenticated and request.user.is_member
            if not is_member:
                logger.warning(f"‚ùå Object member permission denied for article: {getattr(obj, 'article_title', 'Unknown')}")
            return is_member
        
        logger.debug("‚úÖ Object member permission granted (not member-only content)")
        return True